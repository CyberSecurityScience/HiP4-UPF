// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod upfdriver {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod requests {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REQUEST_UNION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REQUEST_UNION: u8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST_UNION: [RequestUnion; 8] = [
  RequestUnion::NONE,
  RequestUnion::DL_N6_SimpleInsertRequest,
  RequestUnion::DL_N6_SimpleUpdateRequest,
  RequestUnion::DL_N6_SimpleRemoveRequest,
  RequestUnion::UL_N6_SimpleInsertRequest,
  RequestUnion::UL_N6_SimpleUpdateRequest,
  RequestUnion::UL_N6_SimpleRemoveRequest,
  RequestUnion::SetMaidVolThreshold,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RequestUnion(pub u8);
#[allow(non_upper_case_globals)]
impl RequestUnion {
  pub const NONE: Self = Self(0);
  pub const DL_N6_SimpleInsertRequest: Self = Self(1);
  pub const DL_N6_SimpleUpdateRequest: Self = Self(2);
  pub const DL_N6_SimpleRemoveRequest: Self = Self(3);
  pub const UL_N6_SimpleInsertRequest: Self = Self(4);
  pub const UL_N6_SimpleUpdateRequest: Self = Self(5);
  pub const UL_N6_SimpleRemoveRequest: Self = Self(6);
  pub const SetMaidVolThreshold: Self = Self(7);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DL_N6_SimpleInsertRequest,
    Self::DL_N6_SimpleUpdateRequest,
    Self::DL_N6_SimpleRemoveRequest,
    Self::UL_N6_SimpleInsertRequest,
    Self::UL_N6_SimpleUpdateRequest,
    Self::UL_N6_SimpleRemoveRequest,
    Self::SetMaidVolThreshold,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DL_N6_SimpleInsertRequest => Some("DL_N6_SimpleInsertRequest"),
      Self::DL_N6_SimpleUpdateRequest => Some("DL_N6_SimpleUpdateRequest"),
      Self::DL_N6_SimpleRemoveRequest => Some("DL_N6_SimpleRemoveRequest"),
      Self::UL_N6_SimpleInsertRequest => Some("UL_N6_SimpleInsertRequest"),
      Self::UL_N6_SimpleUpdateRequest => Some("UL_N6_SimpleUpdateRequest"),
      Self::UL_N6_SimpleRemoveRequest => Some("UL_N6_SimpleRemoveRequest"),
      Self::SetMaidVolThreshold => Some("SetMaidVolThreshold"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RequestUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RequestUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RequestUnion {
    type Output = RequestUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RequestUnion {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RequestUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RequestUnion {}
pub struct RequestUnionUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum RequestUnionT {
  NONE,
  DLN6SimpleInsertRequest(Box<DL_N6_SimpleInsertRequestT>),
  DLN6SimpleUpdateRequest(Box<DL_N6_SimpleUpdateRequestT>),
  DLN6SimpleRemoveRequest(Box<DL_N6_SimpleRemoveRequestT>),
  ULN6SimpleInsertRequest(Box<UL_N6_SimpleInsertRequestT>),
  ULN6SimpleUpdateRequest(Box<UL_N6_SimpleUpdateRequestT>),
  ULN6SimpleRemoveRequest(Box<UL_N6_SimpleRemoveRequestT>),
  SetMaidVolThreshold(Box<SetMaidVolThresholdT>),
}
impl Default for RequestUnionT {
  fn default() -> Self {
    Self::NONE
  }
}
impl RequestUnionT {
  pub fn request_union_type(&self) -> RequestUnion {
    match self {
      Self::NONE => RequestUnion::NONE,
      Self::DLN6SimpleInsertRequest(_) => RequestUnion::DL_N6_SimpleInsertRequest,
      Self::DLN6SimpleUpdateRequest(_) => RequestUnion::DL_N6_SimpleUpdateRequest,
      Self::DLN6SimpleRemoveRequest(_) => RequestUnion::DL_N6_SimpleRemoveRequest,
      Self::ULN6SimpleInsertRequest(_) => RequestUnion::UL_N6_SimpleInsertRequest,
      Self::ULN6SimpleUpdateRequest(_) => RequestUnion::UL_N6_SimpleUpdateRequest,
      Self::ULN6SimpleRemoveRequest(_) => RequestUnion::UL_N6_SimpleRemoveRequest,
      Self::SetMaidVolThreshold(_) => RequestUnion::SetMaidVolThreshold,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::DLN6SimpleInsertRequest(v) => Some(v.pack(fbb).as_union_value()),
      Self::DLN6SimpleUpdateRequest(v) => Some(v.pack(fbb).as_union_value()),
      Self::DLN6SimpleRemoveRequest(v) => Some(v.pack(fbb).as_union_value()),
      Self::ULN6SimpleInsertRequest(v) => Some(v.pack(fbb).as_union_value()),
      Self::ULN6SimpleUpdateRequest(v) => Some(v.pack(fbb).as_union_value()),
      Self::ULN6SimpleRemoveRequest(v) => Some(v.pack(fbb).as_union_value()),
      Self::SetMaidVolThreshold(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned DL_N6_SimpleInsertRequestT, setting the union to NONE.
  pub fn take_dl_n6_simple_insert_request(&mut self) -> Option<Box<DL_N6_SimpleInsertRequestT>> {
    if let Self::DLN6SimpleInsertRequest(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DLN6SimpleInsertRequest(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DL_N6_SimpleInsertRequestT.
  pub fn as_dl_n6_simple_insert_request(&self) -> Option<&DL_N6_SimpleInsertRequestT> {
    if let Self::DLN6SimpleInsertRequest(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DL_N6_SimpleInsertRequestT.
  pub fn as_dl_n6_simple_insert_request_mut(&mut self) -> Option<&mut DL_N6_SimpleInsertRequestT> {
    if let Self::DLN6SimpleInsertRequest(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned DL_N6_SimpleUpdateRequestT, setting the union to NONE.
  pub fn take_dl_n6_simple_update_request(&mut self) -> Option<Box<DL_N6_SimpleUpdateRequestT>> {
    if let Self::DLN6SimpleUpdateRequest(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DLN6SimpleUpdateRequest(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DL_N6_SimpleUpdateRequestT.
  pub fn as_dl_n6_simple_update_request(&self) -> Option<&DL_N6_SimpleUpdateRequestT> {
    if let Self::DLN6SimpleUpdateRequest(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DL_N6_SimpleUpdateRequestT.
  pub fn as_dl_n6_simple_update_request_mut(&mut self) -> Option<&mut DL_N6_SimpleUpdateRequestT> {
    if let Self::DLN6SimpleUpdateRequest(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned DL_N6_SimpleRemoveRequestT, setting the union to NONE.
  pub fn take_dl_n6_simple_remove_request(&mut self) -> Option<Box<DL_N6_SimpleRemoveRequestT>> {
    if let Self::DLN6SimpleRemoveRequest(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DLN6SimpleRemoveRequest(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DL_N6_SimpleRemoveRequestT.
  pub fn as_dl_n6_simple_remove_request(&self) -> Option<&DL_N6_SimpleRemoveRequestT> {
    if let Self::DLN6SimpleRemoveRequest(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DL_N6_SimpleRemoveRequestT.
  pub fn as_dl_n6_simple_remove_request_mut(&mut self) -> Option<&mut DL_N6_SimpleRemoveRequestT> {
    if let Self::DLN6SimpleRemoveRequest(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UL_N6_SimpleInsertRequestT, setting the union to NONE.
  pub fn take_ul_n6_simple_insert_request(&mut self) -> Option<Box<UL_N6_SimpleInsertRequestT>> {
    if let Self::ULN6SimpleInsertRequest(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ULN6SimpleInsertRequest(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UL_N6_SimpleInsertRequestT.
  pub fn as_ul_n6_simple_insert_request(&self) -> Option<&UL_N6_SimpleInsertRequestT> {
    if let Self::ULN6SimpleInsertRequest(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UL_N6_SimpleInsertRequestT.
  pub fn as_ul_n6_simple_insert_request_mut(&mut self) -> Option<&mut UL_N6_SimpleInsertRequestT> {
    if let Self::ULN6SimpleInsertRequest(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UL_N6_SimpleUpdateRequestT, setting the union to NONE.
  pub fn take_ul_n6_simple_update_request(&mut self) -> Option<Box<UL_N6_SimpleUpdateRequestT>> {
    if let Self::ULN6SimpleUpdateRequest(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ULN6SimpleUpdateRequest(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UL_N6_SimpleUpdateRequestT.
  pub fn as_ul_n6_simple_update_request(&self) -> Option<&UL_N6_SimpleUpdateRequestT> {
    if let Self::ULN6SimpleUpdateRequest(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UL_N6_SimpleUpdateRequestT.
  pub fn as_ul_n6_simple_update_request_mut(&mut self) -> Option<&mut UL_N6_SimpleUpdateRequestT> {
    if let Self::ULN6SimpleUpdateRequest(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UL_N6_SimpleRemoveRequestT, setting the union to NONE.
  pub fn take_ul_n6_simple_remove_request(&mut self) -> Option<Box<UL_N6_SimpleRemoveRequestT>> {
    if let Self::ULN6SimpleRemoveRequest(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ULN6SimpleRemoveRequest(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UL_N6_SimpleRemoveRequestT.
  pub fn as_ul_n6_simple_remove_request(&self) -> Option<&UL_N6_SimpleRemoveRequestT> {
    if let Self::ULN6SimpleRemoveRequest(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UL_N6_SimpleRemoveRequestT.
  pub fn as_ul_n6_simple_remove_request_mut(&mut self) -> Option<&mut UL_N6_SimpleRemoveRequestT> {
    if let Self::ULN6SimpleRemoveRequest(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SetMaidVolThresholdT, setting the union to NONE.
  pub fn take_set_maid_vol_threshold(&mut self) -> Option<Box<SetMaidVolThresholdT>> {
    if let Self::SetMaidVolThreshold(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SetMaidVolThreshold(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SetMaidVolThresholdT.
  pub fn as_set_maid_vol_threshold(&self) -> Option<&SetMaidVolThresholdT> {
    if let Self::SetMaidVolThreshold(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SetMaidVolThresholdT.
  pub fn as_set_maid_vol_threshold_mut(&mut self) -> Option<&mut SetMaidVolThresholdT> {
    if let Self::SetMaidVolThreshold(v) = self { Some(v.as_mut()) } else { None }
  }
}
pub enum DL_N6_SimpleInsertRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DL_N6_SimpleInsertRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DL_N6_SimpleInsertRequest<'a> {
  type Inner = DL_N6_SimpleInsertRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DL_N6_SimpleInsertRequest<'a> {
  pub const VT_KEY_IPV4: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_MA_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_TEID: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_QER_ID: flatbuffers::VOffsetT = 10;
  pub const VT_VOL_THRES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DL_N6_SimpleInsertRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DL_N6_SimpleInsertRequestArgs
  ) -> flatbuffers::WIPOffset<DL_N6_SimpleInsertRequest<'bldr>> {
    let mut builder = DL_N6_SimpleInsertRequestBuilder::new(_fbb);
    builder.add_vol_thres(args.vol_thres);
    builder.add_data_teid(args.data_teid);
    builder.add_data_ma_id(args.data_ma_id);
    builder.add_key_ipv4(args.key_ipv4);
    builder.add_data_qer_id(args.data_qer_id);
    builder.finish()
  }

  pub fn unpack(&self) -> DL_N6_SimpleInsertRequestT {
    let key_ipv4 = self.key_ipv4();
    let data_ma_id = self.data_ma_id();
    let data_teid = self.data_teid();
    let data_qer_id = self.data_qer_id();
    let vol_thres = self.vol_thres();
    DL_N6_SimpleInsertRequestT {
      key_ipv4,
      data_ma_id,
      data_teid,
      data_qer_id,
      vol_thres,
    }
  }

  #[inline]
  pub fn key_ipv4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleInsertRequest::VT_KEY_IPV4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleInsertRequest::VT_DATA_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_teid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleInsertRequest::VT_DATA_TEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_qer_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DL_N6_SimpleInsertRequest::VT_DATA_QER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vol_thres(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DL_N6_SimpleInsertRequest::VT_VOL_THRES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DL_N6_SimpleInsertRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("key_ipv4", Self::VT_KEY_IPV4, false)?
     .visit_field::<u32>("data_ma_id", Self::VT_DATA_MA_ID, false)?
     .visit_field::<u32>("data_teid", Self::VT_DATA_TEID, false)?
     .visit_field::<u16>("data_qer_id", Self::VT_DATA_QER_ID, false)?
     .visit_field::<u64>("vol_thres", Self::VT_VOL_THRES, false)?
     .finish();
    Ok(())
  }
}
pub struct DL_N6_SimpleInsertRequestArgs {
    pub key_ipv4: u32,
    pub data_ma_id: u32,
    pub data_teid: u32,
    pub data_qer_id: u16,
    pub vol_thres: u64,
}
impl<'a> Default for DL_N6_SimpleInsertRequestArgs {
  #[inline]
  fn default() -> Self {
    DL_N6_SimpleInsertRequestArgs {
      key_ipv4: 0,
      data_ma_id: 0,
      data_teid: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}

pub struct DL_N6_SimpleInsertRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DL_N6_SimpleInsertRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_ipv4(&mut self, key_ipv4: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleInsertRequest::VT_KEY_IPV4, key_ipv4, 0);
  }
  #[inline]
  pub fn add_data_ma_id(&mut self, data_ma_id: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleInsertRequest::VT_DATA_MA_ID, data_ma_id, 0);
  }
  #[inline]
  pub fn add_data_teid(&mut self, data_teid: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleInsertRequest::VT_DATA_TEID, data_teid, 0);
  }
  #[inline]
  pub fn add_data_qer_id(&mut self, data_qer_id: u16) {
    self.fbb_.push_slot::<u16>(DL_N6_SimpleInsertRequest::VT_DATA_QER_ID, data_qer_id, 0);
  }
  #[inline]
  pub fn add_vol_thres(&mut self, vol_thres: u64) {
    self.fbb_.push_slot::<u64>(DL_N6_SimpleInsertRequest::VT_VOL_THRES, vol_thres, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DL_N6_SimpleInsertRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DL_N6_SimpleInsertRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DL_N6_SimpleInsertRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DL_N6_SimpleInsertRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DL_N6_SimpleInsertRequest");
      ds.field("key_ipv4", &self.key_ipv4());
      ds.field("data_ma_id", &self.data_ma_id());
      ds.field("data_teid", &self.data_teid());
      ds.field("data_qer_id", &self.data_qer_id());
      ds.field("vol_thres", &self.vol_thres());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DL_N6_SimpleInsertRequestT {
  pub key_ipv4: u32,
  pub data_ma_id: u32,
  pub data_teid: u32,
  pub data_qer_id: u16,
  pub vol_thres: u64,
}
impl Default for DL_N6_SimpleInsertRequestT {
  fn default() -> Self {
    Self {
      key_ipv4: 0,
      data_ma_id: 0,
      data_teid: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}
impl DL_N6_SimpleInsertRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DL_N6_SimpleInsertRequest<'b>> {
    let key_ipv4 = self.key_ipv4;
    let data_ma_id = self.data_ma_id;
    let data_teid = self.data_teid;
    let data_qer_id = self.data_qer_id;
    let vol_thres = self.vol_thres;
    DL_N6_SimpleInsertRequest::create(_fbb, &DL_N6_SimpleInsertRequestArgs{
      key_ipv4,
      data_ma_id,
      data_teid,
      data_qer_id,
      vol_thres,
    })
  }
}
pub enum DL_N6_SimpleUpdateRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DL_N6_SimpleUpdateRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DL_N6_SimpleUpdateRequest<'a> {
  type Inner = DL_N6_SimpleUpdateRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DL_N6_SimpleUpdateRequest<'a> {
  pub const VT_KEY_IPV4: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_MA_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_OLD_MA_ID: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_TEID: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_QER_ID: flatbuffers::VOffsetT = 12;
  pub const VT_VOL_THRES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DL_N6_SimpleUpdateRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DL_N6_SimpleUpdateRequestArgs
  ) -> flatbuffers::WIPOffset<DL_N6_SimpleUpdateRequest<'bldr>> {
    let mut builder = DL_N6_SimpleUpdateRequestBuilder::new(_fbb);
    builder.add_vol_thres(args.vol_thres);
    builder.add_data_teid(args.data_teid);
    builder.add_data_old_ma_id(args.data_old_ma_id);
    builder.add_data_ma_id(args.data_ma_id);
    builder.add_key_ipv4(args.key_ipv4);
    builder.add_data_qer_id(args.data_qer_id);
    builder.finish()
  }

  pub fn unpack(&self) -> DL_N6_SimpleUpdateRequestT {
    let key_ipv4 = self.key_ipv4();
    let data_ma_id = self.data_ma_id();
    let data_old_ma_id = self.data_old_ma_id();
    let data_teid = self.data_teid();
    let data_qer_id = self.data_qer_id();
    let vol_thres = self.vol_thres();
    DL_N6_SimpleUpdateRequestT {
      key_ipv4,
      data_ma_id,
      data_old_ma_id,
      data_teid,
      data_qer_id,
      vol_thres,
    }
  }

  #[inline]
  pub fn key_ipv4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleUpdateRequest::VT_KEY_IPV4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleUpdateRequest::VT_DATA_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_old_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleUpdateRequest::VT_DATA_OLD_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_teid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleUpdateRequest::VT_DATA_TEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_qer_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DL_N6_SimpleUpdateRequest::VT_DATA_QER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vol_thres(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DL_N6_SimpleUpdateRequest::VT_VOL_THRES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DL_N6_SimpleUpdateRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("key_ipv4", Self::VT_KEY_IPV4, false)?
     .visit_field::<u32>("data_ma_id", Self::VT_DATA_MA_ID, false)?
     .visit_field::<u32>("data_old_ma_id", Self::VT_DATA_OLD_MA_ID, false)?
     .visit_field::<u32>("data_teid", Self::VT_DATA_TEID, false)?
     .visit_field::<u16>("data_qer_id", Self::VT_DATA_QER_ID, false)?
     .visit_field::<u64>("vol_thres", Self::VT_VOL_THRES, false)?
     .finish();
    Ok(())
  }
}
pub struct DL_N6_SimpleUpdateRequestArgs {
    pub key_ipv4: u32,
    pub data_ma_id: u32,
    pub data_old_ma_id: u32,
    pub data_teid: u32,
    pub data_qer_id: u16,
    pub vol_thres: u64,
}
impl<'a> Default for DL_N6_SimpleUpdateRequestArgs {
  #[inline]
  fn default() -> Self {
    DL_N6_SimpleUpdateRequestArgs {
      key_ipv4: 0,
      data_ma_id: 0,
      data_old_ma_id: 0,
      data_teid: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}

pub struct DL_N6_SimpleUpdateRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DL_N6_SimpleUpdateRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_ipv4(&mut self, key_ipv4: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleUpdateRequest::VT_KEY_IPV4, key_ipv4, 0);
  }
  #[inline]
  pub fn add_data_ma_id(&mut self, data_ma_id: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleUpdateRequest::VT_DATA_MA_ID, data_ma_id, 0);
  }
  #[inline]
  pub fn add_data_old_ma_id(&mut self, data_old_ma_id: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleUpdateRequest::VT_DATA_OLD_MA_ID, data_old_ma_id, 0);
  }
  #[inline]
  pub fn add_data_teid(&mut self, data_teid: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleUpdateRequest::VT_DATA_TEID, data_teid, 0);
  }
  #[inline]
  pub fn add_data_qer_id(&mut self, data_qer_id: u16) {
    self.fbb_.push_slot::<u16>(DL_N6_SimpleUpdateRequest::VT_DATA_QER_ID, data_qer_id, 0);
  }
  #[inline]
  pub fn add_vol_thres(&mut self, vol_thres: u64) {
    self.fbb_.push_slot::<u64>(DL_N6_SimpleUpdateRequest::VT_VOL_THRES, vol_thres, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DL_N6_SimpleUpdateRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DL_N6_SimpleUpdateRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DL_N6_SimpleUpdateRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DL_N6_SimpleUpdateRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DL_N6_SimpleUpdateRequest");
      ds.field("key_ipv4", &self.key_ipv4());
      ds.field("data_ma_id", &self.data_ma_id());
      ds.field("data_old_ma_id", &self.data_old_ma_id());
      ds.field("data_teid", &self.data_teid());
      ds.field("data_qer_id", &self.data_qer_id());
      ds.field("vol_thres", &self.vol_thres());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DL_N6_SimpleUpdateRequestT {
  pub key_ipv4: u32,
  pub data_ma_id: u32,
  pub data_old_ma_id: u32,
  pub data_teid: u32,
  pub data_qer_id: u16,
  pub vol_thres: u64,
}
impl Default for DL_N6_SimpleUpdateRequestT {
  fn default() -> Self {
    Self {
      key_ipv4: 0,
      data_ma_id: 0,
      data_old_ma_id: 0,
      data_teid: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}
impl DL_N6_SimpleUpdateRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DL_N6_SimpleUpdateRequest<'b>> {
    let key_ipv4 = self.key_ipv4;
    let data_ma_id = self.data_ma_id;
    let data_old_ma_id = self.data_old_ma_id;
    let data_teid = self.data_teid;
    let data_qer_id = self.data_qer_id;
    let vol_thres = self.vol_thres;
    DL_N6_SimpleUpdateRequest::create(_fbb, &DL_N6_SimpleUpdateRequestArgs{
      key_ipv4,
      data_ma_id,
      data_old_ma_id,
      data_teid,
      data_qer_id,
      vol_thres,
    })
  }
}
pub enum DL_N6_SimpleRemoveRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DL_N6_SimpleRemoveRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DL_N6_SimpleRemoveRequest<'a> {
  type Inner = DL_N6_SimpleRemoveRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DL_N6_SimpleRemoveRequest<'a> {
  pub const VT_KEY_IPV4: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_OLD_MA_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DL_N6_SimpleRemoveRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DL_N6_SimpleRemoveRequestArgs
  ) -> flatbuffers::WIPOffset<DL_N6_SimpleRemoveRequest<'bldr>> {
    let mut builder = DL_N6_SimpleRemoveRequestBuilder::new(_fbb);
    builder.add_data_old_ma_id(args.data_old_ma_id);
    builder.add_key_ipv4(args.key_ipv4);
    builder.finish()
  }

  pub fn unpack(&self) -> DL_N6_SimpleRemoveRequestT {
    let key_ipv4 = self.key_ipv4();
    let data_old_ma_id = self.data_old_ma_id();
    DL_N6_SimpleRemoveRequestT {
      key_ipv4,
      data_old_ma_id,
    }
  }

  #[inline]
  pub fn key_ipv4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleRemoveRequest::VT_KEY_IPV4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_old_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DL_N6_SimpleRemoveRequest::VT_DATA_OLD_MA_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DL_N6_SimpleRemoveRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("key_ipv4", Self::VT_KEY_IPV4, false)?
     .visit_field::<u32>("data_old_ma_id", Self::VT_DATA_OLD_MA_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct DL_N6_SimpleRemoveRequestArgs {
    pub key_ipv4: u32,
    pub data_old_ma_id: u32,
}
impl<'a> Default for DL_N6_SimpleRemoveRequestArgs {
  #[inline]
  fn default() -> Self {
    DL_N6_SimpleRemoveRequestArgs {
      key_ipv4: 0,
      data_old_ma_id: 0,
    }
  }
}

pub struct DL_N6_SimpleRemoveRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DL_N6_SimpleRemoveRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_ipv4(&mut self, key_ipv4: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleRemoveRequest::VT_KEY_IPV4, key_ipv4, 0);
  }
  #[inline]
  pub fn add_data_old_ma_id(&mut self, data_old_ma_id: u32) {
    self.fbb_.push_slot::<u32>(DL_N6_SimpleRemoveRequest::VT_DATA_OLD_MA_ID, data_old_ma_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DL_N6_SimpleRemoveRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DL_N6_SimpleRemoveRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DL_N6_SimpleRemoveRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DL_N6_SimpleRemoveRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DL_N6_SimpleRemoveRequest");
      ds.field("key_ipv4", &self.key_ipv4());
      ds.field("data_old_ma_id", &self.data_old_ma_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DL_N6_SimpleRemoveRequestT {
  pub key_ipv4: u32,
  pub data_old_ma_id: u32,
}
impl Default for DL_N6_SimpleRemoveRequestT {
  fn default() -> Self {
    Self {
      key_ipv4: 0,
      data_old_ma_id: 0,
    }
  }
}
impl DL_N6_SimpleRemoveRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DL_N6_SimpleRemoveRequest<'b>> {
    let key_ipv4 = self.key_ipv4;
    let data_old_ma_id = self.data_old_ma_id;
    DL_N6_SimpleRemoveRequest::create(_fbb, &DL_N6_SimpleRemoveRequestArgs{
      key_ipv4,
      data_old_ma_id,
    })
  }
}
pub enum UL_N6_SimpleInsertRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UL_N6_SimpleInsertRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UL_N6_SimpleInsertRequest<'a> {
  type Inner = UL_N6_SimpleInsertRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UL_N6_SimpleInsertRequest<'a> {
  pub const VT_KEY_TEID: flatbuffers::VOffsetT = 4;
  pub const VT_KEY_QFI: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_MA_ID: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_QER_ID: flatbuffers::VOffsetT = 10;
  pub const VT_VOL_THRES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UL_N6_SimpleInsertRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UL_N6_SimpleInsertRequestArgs
  ) -> flatbuffers::WIPOffset<UL_N6_SimpleInsertRequest<'bldr>> {
    let mut builder = UL_N6_SimpleInsertRequestBuilder::new(_fbb);
    builder.add_vol_thres(args.vol_thres);
    builder.add_data_ma_id(args.data_ma_id);
    builder.add_key_teid(args.key_teid);
    builder.add_data_qer_id(args.data_qer_id);
    builder.add_key_qfi(args.key_qfi);
    builder.finish()
  }

  pub fn unpack(&self) -> UL_N6_SimpleInsertRequestT {
    let key_teid = self.key_teid();
    let key_qfi = self.key_qfi();
    let data_ma_id = self.data_ma_id();
    let data_qer_id = self.data_qer_id();
    let vol_thres = self.vol_thres();
    UL_N6_SimpleInsertRequestT {
      key_teid,
      key_qfi,
      data_ma_id,
      data_qer_id,
      vol_thres,
    }
  }

  #[inline]
  pub fn key_teid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleInsertRequest::VT_KEY_TEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_qfi(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(UL_N6_SimpleInsertRequest::VT_KEY_QFI, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleInsertRequest::VT_DATA_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_qer_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(UL_N6_SimpleInsertRequest::VT_DATA_QER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vol_thres(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UL_N6_SimpleInsertRequest::VT_VOL_THRES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UL_N6_SimpleInsertRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("key_teid", Self::VT_KEY_TEID, false)?
     .visit_field::<u8>("key_qfi", Self::VT_KEY_QFI, false)?
     .visit_field::<u32>("data_ma_id", Self::VT_DATA_MA_ID, false)?
     .visit_field::<u16>("data_qer_id", Self::VT_DATA_QER_ID, false)?
     .visit_field::<u64>("vol_thres", Self::VT_VOL_THRES, false)?
     .finish();
    Ok(())
  }
}
pub struct UL_N6_SimpleInsertRequestArgs {
    pub key_teid: u32,
    pub key_qfi: u8,
    pub data_ma_id: u32,
    pub data_qer_id: u16,
    pub vol_thres: u64,
}
impl<'a> Default for UL_N6_SimpleInsertRequestArgs {
  #[inline]
  fn default() -> Self {
    UL_N6_SimpleInsertRequestArgs {
      key_teid: 0,
      key_qfi: 0,
      data_ma_id: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}

pub struct UL_N6_SimpleInsertRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UL_N6_SimpleInsertRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_teid(&mut self, key_teid: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleInsertRequest::VT_KEY_TEID, key_teid, 0);
  }
  #[inline]
  pub fn add_key_qfi(&mut self, key_qfi: u8) {
    self.fbb_.push_slot::<u8>(UL_N6_SimpleInsertRequest::VT_KEY_QFI, key_qfi, 0);
  }
  #[inline]
  pub fn add_data_ma_id(&mut self, data_ma_id: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleInsertRequest::VT_DATA_MA_ID, data_ma_id, 0);
  }
  #[inline]
  pub fn add_data_qer_id(&mut self, data_qer_id: u16) {
    self.fbb_.push_slot::<u16>(UL_N6_SimpleInsertRequest::VT_DATA_QER_ID, data_qer_id, 0);
  }
  #[inline]
  pub fn add_vol_thres(&mut self, vol_thres: u64) {
    self.fbb_.push_slot::<u64>(UL_N6_SimpleInsertRequest::VT_VOL_THRES, vol_thres, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UL_N6_SimpleInsertRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UL_N6_SimpleInsertRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UL_N6_SimpleInsertRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UL_N6_SimpleInsertRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UL_N6_SimpleInsertRequest");
      ds.field("key_teid", &self.key_teid());
      ds.field("key_qfi", &self.key_qfi());
      ds.field("data_ma_id", &self.data_ma_id());
      ds.field("data_qer_id", &self.data_qer_id());
      ds.field("vol_thres", &self.vol_thres());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UL_N6_SimpleInsertRequestT {
  pub key_teid: u32,
  pub key_qfi: u8,
  pub data_ma_id: u32,
  pub data_qer_id: u16,
  pub vol_thres: u64,
}
impl Default for UL_N6_SimpleInsertRequestT {
  fn default() -> Self {
    Self {
      key_teid: 0,
      key_qfi: 0,
      data_ma_id: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}
impl UL_N6_SimpleInsertRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<UL_N6_SimpleInsertRequest<'b>> {
    let key_teid = self.key_teid;
    let key_qfi = self.key_qfi;
    let data_ma_id = self.data_ma_id;
    let data_qer_id = self.data_qer_id;
    let vol_thres = self.vol_thres;
    UL_N6_SimpleInsertRequest::create(_fbb, &UL_N6_SimpleInsertRequestArgs{
      key_teid,
      key_qfi,
      data_ma_id,
      data_qer_id,
      vol_thres,
    })
  }
}
pub enum UL_N6_SimpleUpdateRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UL_N6_SimpleUpdateRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UL_N6_SimpleUpdateRequest<'a> {
  type Inner = UL_N6_SimpleUpdateRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UL_N6_SimpleUpdateRequest<'a> {
  pub const VT_KEY_TEID: flatbuffers::VOffsetT = 4;
  pub const VT_KEY_QFI: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_MA_ID: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_OLD_MA_ID: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_QER_ID: flatbuffers::VOffsetT = 12;
  pub const VT_VOL_THRES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UL_N6_SimpleUpdateRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UL_N6_SimpleUpdateRequestArgs
  ) -> flatbuffers::WIPOffset<UL_N6_SimpleUpdateRequest<'bldr>> {
    let mut builder = UL_N6_SimpleUpdateRequestBuilder::new(_fbb);
    builder.add_vol_thres(args.vol_thres);
    builder.add_data_old_ma_id(args.data_old_ma_id);
    builder.add_data_ma_id(args.data_ma_id);
    builder.add_key_teid(args.key_teid);
    builder.add_data_qer_id(args.data_qer_id);
    builder.add_key_qfi(args.key_qfi);
    builder.finish()
  }

  pub fn unpack(&self) -> UL_N6_SimpleUpdateRequestT {
    let key_teid = self.key_teid();
    let key_qfi = self.key_qfi();
    let data_ma_id = self.data_ma_id();
    let data_old_ma_id = self.data_old_ma_id();
    let data_qer_id = self.data_qer_id();
    let vol_thres = self.vol_thres();
    UL_N6_SimpleUpdateRequestT {
      key_teid,
      key_qfi,
      data_ma_id,
      data_old_ma_id,
      data_qer_id,
      vol_thres,
    }
  }

  #[inline]
  pub fn key_teid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleUpdateRequest::VT_KEY_TEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_qfi(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(UL_N6_SimpleUpdateRequest::VT_KEY_QFI, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleUpdateRequest::VT_DATA_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_old_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleUpdateRequest::VT_DATA_OLD_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_qer_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(UL_N6_SimpleUpdateRequest::VT_DATA_QER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vol_thres(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UL_N6_SimpleUpdateRequest::VT_VOL_THRES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UL_N6_SimpleUpdateRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("key_teid", Self::VT_KEY_TEID, false)?
     .visit_field::<u8>("key_qfi", Self::VT_KEY_QFI, false)?
     .visit_field::<u32>("data_ma_id", Self::VT_DATA_MA_ID, false)?
     .visit_field::<u32>("data_old_ma_id", Self::VT_DATA_OLD_MA_ID, false)?
     .visit_field::<u16>("data_qer_id", Self::VT_DATA_QER_ID, false)?
     .visit_field::<u64>("vol_thres", Self::VT_VOL_THRES, false)?
     .finish();
    Ok(())
  }
}
pub struct UL_N6_SimpleUpdateRequestArgs {
    pub key_teid: u32,
    pub key_qfi: u8,
    pub data_ma_id: u32,
    pub data_old_ma_id: u32,
    pub data_qer_id: u16,
    pub vol_thres: u64,
}
impl<'a> Default for UL_N6_SimpleUpdateRequestArgs {
  #[inline]
  fn default() -> Self {
    UL_N6_SimpleUpdateRequestArgs {
      key_teid: 0,
      key_qfi: 0,
      data_ma_id: 0,
      data_old_ma_id: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}

pub struct UL_N6_SimpleUpdateRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UL_N6_SimpleUpdateRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_teid(&mut self, key_teid: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleUpdateRequest::VT_KEY_TEID, key_teid, 0);
  }
  #[inline]
  pub fn add_key_qfi(&mut self, key_qfi: u8) {
    self.fbb_.push_slot::<u8>(UL_N6_SimpleUpdateRequest::VT_KEY_QFI, key_qfi, 0);
  }
  #[inline]
  pub fn add_data_ma_id(&mut self, data_ma_id: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleUpdateRequest::VT_DATA_MA_ID, data_ma_id, 0);
  }
  #[inline]
  pub fn add_data_old_ma_id(&mut self, data_old_ma_id: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleUpdateRequest::VT_DATA_OLD_MA_ID, data_old_ma_id, 0);
  }
  #[inline]
  pub fn add_data_qer_id(&mut self, data_qer_id: u16) {
    self.fbb_.push_slot::<u16>(UL_N6_SimpleUpdateRequest::VT_DATA_QER_ID, data_qer_id, 0);
  }
  #[inline]
  pub fn add_vol_thres(&mut self, vol_thres: u64) {
    self.fbb_.push_slot::<u64>(UL_N6_SimpleUpdateRequest::VT_VOL_THRES, vol_thres, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UL_N6_SimpleUpdateRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UL_N6_SimpleUpdateRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UL_N6_SimpleUpdateRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UL_N6_SimpleUpdateRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UL_N6_SimpleUpdateRequest");
      ds.field("key_teid", &self.key_teid());
      ds.field("key_qfi", &self.key_qfi());
      ds.field("data_ma_id", &self.data_ma_id());
      ds.field("data_old_ma_id", &self.data_old_ma_id());
      ds.field("data_qer_id", &self.data_qer_id());
      ds.field("vol_thres", &self.vol_thres());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UL_N6_SimpleUpdateRequestT {
  pub key_teid: u32,
  pub key_qfi: u8,
  pub data_ma_id: u32,
  pub data_old_ma_id: u32,
  pub data_qer_id: u16,
  pub vol_thres: u64,
}
impl Default for UL_N6_SimpleUpdateRequestT {
  fn default() -> Self {
    Self {
      key_teid: 0,
      key_qfi: 0,
      data_ma_id: 0,
      data_old_ma_id: 0,
      data_qer_id: 0,
      vol_thres: 0,
    }
  }
}
impl UL_N6_SimpleUpdateRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<UL_N6_SimpleUpdateRequest<'b>> {
    let key_teid = self.key_teid;
    let key_qfi = self.key_qfi;
    let data_ma_id = self.data_ma_id;
    let data_old_ma_id = self.data_old_ma_id;
    let data_qer_id = self.data_qer_id;
    let vol_thres = self.vol_thres;
    UL_N6_SimpleUpdateRequest::create(_fbb, &UL_N6_SimpleUpdateRequestArgs{
      key_teid,
      key_qfi,
      data_ma_id,
      data_old_ma_id,
      data_qer_id,
      vol_thres,
    })
  }
}
pub enum UL_N6_SimpleRemoveRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UL_N6_SimpleRemoveRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UL_N6_SimpleRemoveRequest<'a> {
  type Inner = UL_N6_SimpleRemoveRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UL_N6_SimpleRemoveRequest<'a> {
  pub const VT_KEY_TEID: flatbuffers::VOffsetT = 4;
  pub const VT_KEY_QFI: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_OLD_MA_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UL_N6_SimpleRemoveRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UL_N6_SimpleRemoveRequestArgs
  ) -> flatbuffers::WIPOffset<UL_N6_SimpleRemoveRequest<'bldr>> {
    let mut builder = UL_N6_SimpleRemoveRequestBuilder::new(_fbb);
    builder.add_data_old_ma_id(args.data_old_ma_id);
    builder.add_key_teid(args.key_teid);
    builder.add_key_qfi(args.key_qfi);
    builder.finish()
  }

  pub fn unpack(&self) -> UL_N6_SimpleRemoveRequestT {
    let key_teid = self.key_teid();
    let key_qfi = self.key_qfi();
    let data_old_ma_id = self.data_old_ma_id();
    UL_N6_SimpleRemoveRequestT {
      key_teid,
      key_qfi,
      data_old_ma_id,
    }
  }

  #[inline]
  pub fn key_teid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleRemoveRequest::VT_KEY_TEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_qfi(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(UL_N6_SimpleRemoveRequest::VT_KEY_QFI, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data_old_ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UL_N6_SimpleRemoveRequest::VT_DATA_OLD_MA_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UL_N6_SimpleRemoveRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("key_teid", Self::VT_KEY_TEID, false)?
     .visit_field::<u8>("key_qfi", Self::VT_KEY_QFI, false)?
     .visit_field::<u32>("data_old_ma_id", Self::VT_DATA_OLD_MA_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct UL_N6_SimpleRemoveRequestArgs {
    pub key_teid: u32,
    pub key_qfi: u8,
    pub data_old_ma_id: u32,
}
impl<'a> Default for UL_N6_SimpleRemoveRequestArgs {
  #[inline]
  fn default() -> Self {
    UL_N6_SimpleRemoveRequestArgs {
      key_teid: 0,
      key_qfi: 0,
      data_old_ma_id: 0,
    }
  }
}

pub struct UL_N6_SimpleRemoveRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UL_N6_SimpleRemoveRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key_teid(&mut self, key_teid: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleRemoveRequest::VT_KEY_TEID, key_teid, 0);
  }
  #[inline]
  pub fn add_key_qfi(&mut self, key_qfi: u8) {
    self.fbb_.push_slot::<u8>(UL_N6_SimpleRemoveRequest::VT_KEY_QFI, key_qfi, 0);
  }
  #[inline]
  pub fn add_data_old_ma_id(&mut self, data_old_ma_id: u32) {
    self.fbb_.push_slot::<u32>(UL_N6_SimpleRemoveRequest::VT_DATA_OLD_MA_ID, data_old_ma_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UL_N6_SimpleRemoveRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UL_N6_SimpleRemoveRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UL_N6_SimpleRemoveRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UL_N6_SimpleRemoveRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UL_N6_SimpleRemoveRequest");
      ds.field("key_teid", &self.key_teid());
      ds.field("key_qfi", &self.key_qfi());
      ds.field("data_old_ma_id", &self.data_old_ma_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UL_N6_SimpleRemoveRequestT {
  pub key_teid: u32,
  pub key_qfi: u8,
  pub data_old_ma_id: u32,
}
impl Default for UL_N6_SimpleRemoveRequestT {
  fn default() -> Self {
    Self {
      key_teid: 0,
      key_qfi: 0,
      data_old_ma_id: 0,
    }
  }
}
impl UL_N6_SimpleRemoveRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<UL_N6_SimpleRemoveRequest<'b>> {
    let key_teid = self.key_teid;
    let key_qfi = self.key_qfi;
    let data_old_ma_id = self.data_old_ma_id;
    UL_N6_SimpleRemoveRequest::create(_fbb, &UL_N6_SimpleRemoveRequestArgs{
      key_teid,
      key_qfi,
      data_old_ma_id,
    })
  }
}
pub enum SetMaidVolThresholdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetMaidVolThreshold<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetMaidVolThreshold<'a> {
  type Inner = SetMaidVolThreshold<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetMaidVolThreshold<'a> {
  pub const VT_MA_ID: flatbuffers::VOffsetT = 4;
  pub const VT_BYTES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetMaidVolThreshold { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetMaidVolThresholdArgs
  ) -> flatbuffers::WIPOffset<SetMaidVolThreshold<'bldr>> {
    let mut builder = SetMaidVolThresholdBuilder::new(_fbb);
    builder.add_bytes(args.bytes);
    builder.add_ma_id(args.ma_id);
    builder.finish()
  }

  pub fn unpack(&self) -> SetMaidVolThresholdT {
    let ma_id = self.ma_id();
    let bytes = self.bytes();
    SetMaidVolThresholdT {
      ma_id,
      bytes,
    }
  }

  #[inline]
  pub fn ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SetMaidVolThreshold::VT_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bytes(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SetMaidVolThreshold::VT_BYTES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SetMaidVolThreshold<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("ma_id", Self::VT_MA_ID, false)?
     .visit_field::<u64>("bytes", Self::VT_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct SetMaidVolThresholdArgs {
    pub ma_id: u32,
    pub bytes: u64,
}
impl<'a> Default for SetMaidVolThresholdArgs {
  #[inline]
  fn default() -> Self {
    SetMaidVolThresholdArgs {
      ma_id: 0,
      bytes: 0,
    }
  }
}

pub struct SetMaidVolThresholdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetMaidVolThresholdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ma_id(&mut self, ma_id: u32) {
    self.fbb_.push_slot::<u32>(SetMaidVolThreshold::VT_MA_ID, ma_id, 0);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: u64) {
    self.fbb_.push_slot::<u64>(SetMaidVolThreshold::VT_BYTES, bytes, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetMaidVolThresholdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetMaidVolThresholdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetMaidVolThreshold<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetMaidVolThreshold<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetMaidVolThreshold");
      ds.field("ma_id", &self.ma_id());
      ds.field("bytes", &self.bytes());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SetMaidVolThresholdT {
  pub ma_id: u32,
  pub bytes: u64,
}
impl Default for SetMaidVolThresholdT {
  fn default() -> Self {
    Self {
      ma_id: 0,
      bytes: 0,
    }
  }
}
impl SetMaidVolThresholdT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SetMaidVolThreshold<'b>> {
    let ma_id = self.ma_id;
    let bytes = self.bytes;
    SetMaidVolThreshold::create(_fbb, &SetMaidVolThresholdArgs{
      ma_id,
      bytes,
    })
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Request<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Request<'a> {
  type Inner = Request<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Request<'a> {
  pub const VT_REQUEST_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_REQUEST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Request { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestArgs
  ) -> flatbuffers::WIPOffset<Request<'bldr>> {
    let mut builder = RequestBuilder::new(_fbb);
    if let Some(x) = args.request { builder.add_request(x); }
    builder.add_request_type(args.request_type);
    builder.finish()
  }

  pub fn unpack(&self) -> RequestT {
    let request = match self.request_type() {
      RequestUnion::NONE => RequestUnionT::NONE,
      RequestUnion::DL_N6_SimpleInsertRequest => RequestUnionT::DLN6SimpleInsertRequest(Box::new(
        self.request_as_dl_n6_simple_insert_request()
            .expect("Invalid union table, expected `RequestUnion::DL_N6_SimpleInsertRequest`.")
            .unpack()
      )),
      RequestUnion::DL_N6_SimpleUpdateRequest => RequestUnionT::DLN6SimpleUpdateRequest(Box::new(
        self.request_as_dl_n6_simple_update_request()
            .expect("Invalid union table, expected `RequestUnion::DL_N6_SimpleUpdateRequest`.")
            .unpack()
      )),
      RequestUnion::DL_N6_SimpleRemoveRequest => RequestUnionT::DLN6SimpleRemoveRequest(Box::new(
        self.request_as_dl_n6_simple_remove_request()
            .expect("Invalid union table, expected `RequestUnion::DL_N6_SimpleRemoveRequest`.")
            .unpack()
      )),
      RequestUnion::UL_N6_SimpleInsertRequest => RequestUnionT::ULN6SimpleInsertRequest(Box::new(
        self.request_as_ul_n6_simple_insert_request()
            .expect("Invalid union table, expected `RequestUnion::UL_N6_SimpleInsertRequest`.")
            .unpack()
      )),
      RequestUnion::UL_N6_SimpleUpdateRequest => RequestUnionT::ULN6SimpleUpdateRequest(Box::new(
        self.request_as_ul_n6_simple_update_request()
            .expect("Invalid union table, expected `RequestUnion::UL_N6_SimpleUpdateRequest`.")
            .unpack()
      )),
      RequestUnion::UL_N6_SimpleRemoveRequest => RequestUnionT::ULN6SimpleRemoveRequest(Box::new(
        self.request_as_ul_n6_simple_remove_request()
            .expect("Invalid union table, expected `RequestUnion::UL_N6_SimpleRemoveRequest`.")
            .unpack()
      )),
      RequestUnion::SetMaidVolThreshold => RequestUnionT::SetMaidVolThreshold(Box::new(
        self.request_as_set_maid_vol_threshold()
            .expect("Invalid union table, expected `RequestUnion::SetMaidVolThreshold`.")
            .unpack()
      )),
      _ => RequestUnionT::NONE,
    };
    RequestT {
      request,
    }
  }

  #[inline]
  pub fn request_type(&self) -> RequestUnion {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RequestUnion>(Request::VT_REQUEST_TYPE, Some(RequestUnion::NONE)).unwrap()}
  }
  #[inline]
  pub fn request(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Request::VT_REQUEST, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_dl_n6_simple_insert_request(&self) -> Option<DL_N6_SimpleInsertRequest<'a>> {
    if self.request_type() == RequestUnion::DL_N6_SimpleInsertRequest {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DL_N6_SimpleInsertRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_dl_n6_simple_update_request(&self) -> Option<DL_N6_SimpleUpdateRequest<'a>> {
    if self.request_type() == RequestUnion::DL_N6_SimpleUpdateRequest {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DL_N6_SimpleUpdateRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_dl_n6_simple_remove_request(&self) -> Option<DL_N6_SimpleRemoveRequest<'a>> {
    if self.request_type() == RequestUnion::DL_N6_SimpleRemoveRequest {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DL_N6_SimpleRemoveRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_ul_n6_simple_insert_request(&self) -> Option<UL_N6_SimpleInsertRequest<'a>> {
    if self.request_type() == RequestUnion::UL_N6_SimpleInsertRequest {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UL_N6_SimpleInsertRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_ul_n6_simple_update_request(&self) -> Option<UL_N6_SimpleUpdateRequest<'a>> {
    if self.request_type() == RequestUnion::UL_N6_SimpleUpdateRequest {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UL_N6_SimpleUpdateRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_ul_n6_simple_remove_request(&self) -> Option<UL_N6_SimpleRemoveRequest<'a>> {
    if self.request_type() == RequestUnion::UL_N6_SimpleRemoveRequest {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UL_N6_SimpleRemoveRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn request_as_set_maid_vol_threshold(&self) -> Option<SetMaidVolThreshold<'a>> {
    if self.request_type() == RequestUnion::SetMaidVolThreshold {
      self.request().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SetMaidVolThreshold::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<RequestUnion, _>("request_type", Self::VT_REQUEST_TYPE, "request", Self::VT_REQUEST, false, |key, v, pos| {
        match key {
          RequestUnion::DL_N6_SimpleInsertRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DL_N6_SimpleInsertRequest>>("RequestUnion::DL_N6_SimpleInsertRequest", pos),
          RequestUnion::DL_N6_SimpleUpdateRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DL_N6_SimpleUpdateRequest>>("RequestUnion::DL_N6_SimpleUpdateRequest", pos),
          RequestUnion::DL_N6_SimpleRemoveRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DL_N6_SimpleRemoveRequest>>("RequestUnion::DL_N6_SimpleRemoveRequest", pos),
          RequestUnion::UL_N6_SimpleInsertRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UL_N6_SimpleInsertRequest>>("RequestUnion::UL_N6_SimpleInsertRequest", pos),
          RequestUnion::UL_N6_SimpleUpdateRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UL_N6_SimpleUpdateRequest>>("RequestUnion::UL_N6_SimpleUpdateRequest", pos),
          RequestUnion::UL_N6_SimpleRemoveRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UL_N6_SimpleRemoveRequest>>("RequestUnion::UL_N6_SimpleRemoveRequest", pos),
          RequestUnion::SetMaidVolThreshold => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetMaidVolThreshold>>("RequestUnion::SetMaidVolThreshold", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs {
    pub request_type: RequestUnion,
    pub request: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RequestArgs {
  #[inline]
  fn default() -> Self {
    RequestArgs {
      request_type: RequestUnion::NONE,
      request: None,
    }
  }
}

pub struct RequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_type(&mut self, request_type: RequestUnion) {
    self.fbb_.push_slot::<RequestUnion>(Request::VT_REQUEST_TYPE, request_type, RequestUnion::NONE);
  }
  #[inline]
  pub fn add_request(&mut self, request: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_REQUEST, request);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("request_type", &self.request_type());
      match self.request_type() {
        RequestUnion::DL_N6_SimpleInsertRequest => {
          if let Some(x) = self.request_as_dl_n6_simple_insert_request() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestUnion::DL_N6_SimpleUpdateRequest => {
          if let Some(x) = self.request_as_dl_n6_simple_update_request() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestUnion::DL_N6_SimpleRemoveRequest => {
          if let Some(x) = self.request_as_dl_n6_simple_remove_request() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestUnion::UL_N6_SimpleInsertRequest => {
          if let Some(x) = self.request_as_ul_n6_simple_insert_request() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestUnion::UL_N6_SimpleUpdateRequest => {
          if let Some(x) = self.request_as_ul_n6_simple_update_request() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestUnion::UL_N6_SimpleRemoveRequest => {
          if let Some(x) = self.request_as_ul_n6_simple_remove_request() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestUnion::SetMaidVolThreshold => {
          if let Some(x) = self.request_as_set_maid_vol_threshold() {
            ds.field("request", &x)
          } else {
            ds.field("request", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("request", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RequestT {
  pub request: RequestUnionT,
}
impl Default for RequestT {
  fn default() -> Self {
    Self {
      request: RequestUnionT::NONE,
    }
  }
}
impl RequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Request<'b>> {
    let request_type = self.request.request_union_type();
    let request = self.request.pack(_fbb);
    Request::create(_fbb, &RequestArgs{
      request_type,
      request,
    })
  }
}
pub enum TransactionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
  type Inner = Transaction<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Transaction<'a> {
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DEADLINE: flatbuffers::VOffsetT = 6;
  pub const VT_OPS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Transaction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionArgs<'args>
  ) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
    let mut builder = TransactionBuilder::new(_fbb);
    builder.add_deadline(args.deadline);
    if let Some(x) = args.ops { builder.add_ops(x); }
    builder.add_transaction_id(args.transaction_id);
    builder.finish()
  }

  pub fn unpack(&self) -> TransactionT {
    let transaction_id = self.transaction_id();
    let deadline = self.deadline();
    let ops = self.ops().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    TransactionT {
      transaction_id,
      deadline,
      ops,
    }
  }

  #[inline]
  pub fn transaction_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Transaction::VT_TRANSACTION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn deadline(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Transaction::VT_DEADLINE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ops(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request>>>>(Transaction::VT_OPS, None)}
  }
}

impl flatbuffers::Verifiable for Transaction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<u64>("deadline", Self::VT_DEADLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Request>>>>("ops", Self::VT_OPS, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionArgs<'a> {
    pub transaction_id: u32,
    pub deadline: u64,
    pub ops: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>>>,
}
impl<'a> Default for TransactionArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionArgs {
      transaction_id: 0,
      deadline: 0,
      ops: None,
    }
  }
}

pub struct TransactionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: u32) {
    self.fbb_.push_slot::<u32>(Transaction::VT_TRANSACTION_ID, transaction_id, 0);
  }
  #[inline]
  pub fn add_deadline(&mut self, deadline: u64) {
    self.fbb_.push_slot::<u64>(Transaction::VT_DEADLINE, deadline, 0);
  }
  #[inline]
  pub fn add_ops(&mut self, ops: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Request<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OPS, ops);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Transaction<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Transaction");
      ds.field("transaction_id", &self.transaction_id());
      ds.field("deadline", &self.deadline());
      ds.field("ops", &self.ops());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionT {
  pub transaction_id: u32,
  pub deadline: u64,
  pub ops: Option<Vec<RequestT>>,
}
impl Default for TransactionT {
  fn default() -> Self {
    Self {
      transaction_id: 0,
      deadline: 0,
      ops: None,
    }
  }
}
impl TransactionT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Transaction<'b>> {
    let transaction_id = self.transaction_id;
    let deadline = self.deadline;
    let ops = self.ops.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Transaction::create(_fbb, &TransactionArgs{
      transaction_id,
      deadline,
      ops,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Transaction`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_transaction_unchecked`.
pub fn root_as_transaction(buf: &[u8]) -> Result<Transaction, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Transaction>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Transaction` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_transaction_unchecked`.
pub fn size_prefixed_root_as_transaction(buf: &[u8]) -> Result<Transaction, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Transaction>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Transaction` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_transaction_unchecked`.
pub fn root_as_transaction_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Transaction<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Transaction<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Transaction` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_transaction_unchecked`.
pub fn size_prefixed_root_as_transaction_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Transaction<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Transaction<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Transaction and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Transaction`.
pub unsafe fn root_as_transaction_unchecked(buf: &[u8]) -> Transaction {
  flatbuffers::root_unchecked::<Transaction>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Transaction and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Transaction`.
pub unsafe fn size_prefixed_root_as_transaction_unchecked(buf: &[u8]) -> Transaction {
  flatbuffers::size_prefixed_root_unchecked::<Transaction>(buf)
}
#[inline]
pub fn finish_transaction_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Transaction<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_transaction_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Transaction<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Requests
}  // pub mod UPFDriver

