// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESPONSE_UPFDRIVER_RESPONSE_H_
#define FLATBUFFERS_GENERATED_RESPONSE_UPFDRIVER_RESPONSE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace UPFDriver {
namespace Response {

struct CounterValue;
struct CounterValueBuilder;
struct CounterValueT;

struct CounterValues;
struct CounterValuesBuilder;
struct CounterValuesT;

struct TableOperationComplete;
struct TableOperationCompleteBuilder;
struct TableOperationCompleteT;

struct MA_ID_Reclaimed;
struct MA_ID_ReclaimedBuilder;
struct MA_ID_ReclaimedT;

struct Response;
struct ResponseBuilder;
struct ResponseT;

enum ResponseUnion : uint8_t {
  ResponseUnion_NONE = 0,
  ResponseUnion_CounterValues = 1,
  ResponseUnion_TableOperationComplete = 2,
  ResponseUnion_MA_ID_Reclaimed = 3,
  ResponseUnion_MIN = ResponseUnion_NONE,
  ResponseUnion_MAX = ResponseUnion_MA_ID_Reclaimed
};

inline const ResponseUnion (&EnumValuesResponseUnion())[4] {
  static const ResponseUnion values[] = {
    ResponseUnion_NONE,
    ResponseUnion_CounterValues,
    ResponseUnion_TableOperationComplete,
    ResponseUnion_MA_ID_Reclaimed
  };
  return values;
}

inline const char * const *EnumNamesResponseUnion() {
  static const char * const names[5] = {
    "NONE",
    "CounterValues",
    "TableOperationComplete",
    "MA_ID_Reclaimed",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseUnion(ResponseUnion e) {
  if (::flatbuffers::IsOutRange(e, ResponseUnion_NONE, ResponseUnion_MA_ID_Reclaimed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponseUnion()[index];
}

template<typename T> struct ResponseUnionTraits {
  static const ResponseUnion enum_value = ResponseUnion_NONE;
};

template<> struct ResponseUnionTraits<UPFDriver::Response::CounterValues> {
  static const ResponseUnion enum_value = ResponseUnion_CounterValues;
};

template<> struct ResponseUnionTraits<UPFDriver::Response::TableOperationComplete> {
  static const ResponseUnion enum_value = ResponseUnion_TableOperationComplete;
};

template<> struct ResponseUnionTraits<UPFDriver::Response::MA_ID_Reclaimed> {
  static const ResponseUnion enum_value = ResponseUnion_MA_ID_Reclaimed;
};

template<typename T> struct ResponseUnionUnionTraits {
  static const ResponseUnion enum_value = ResponseUnion_NONE;
};

template<> struct ResponseUnionUnionTraits<UPFDriver::Response::CounterValuesT> {
  static const ResponseUnion enum_value = ResponseUnion_CounterValues;
};

template<> struct ResponseUnionUnionTraits<UPFDriver::Response::TableOperationCompleteT> {
  static const ResponseUnion enum_value = ResponseUnion_TableOperationComplete;
};

template<> struct ResponseUnionUnionTraits<UPFDriver::Response::MA_ID_ReclaimedT> {
  static const ResponseUnion enum_value = ResponseUnion_MA_ID_Reclaimed;
};

struct ResponseUnionUnion {
  ResponseUnion type;
  void *value;

  ResponseUnionUnion() : type(ResponseUnion_NONE), value(nullptr) {}
  ResponseUnionUnion(ResponseUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ResponseUnion_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ResponseUnionUnion(const ResponseUnionUnion &);
  ResponseUnionUnion &operator=(const ResponseUnionUnion &u)
    { ResponseUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ResponseUnionUnion &operator=(ResponseUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ResponseUnionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ResponseUnionUnionTraits<RT>::enum_value;
    if (type != ResponseUnion_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ResponseUnion type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  UPFDriver::Response::CounterValuesT *AsCounterValues() {
    return type == ResponseUnion_CounterValues ?
      reinterpret_cast<UPFDriver::Response::CounterValuesT *>(value) : nullptr;
  }
  const UPFDriver::Response::CounterValuesT *AsCounterValues() const {
    return type == ResponseUnion_CounterValues ?
      reinterpret_cast<const UPFDriver::Response::CounterValuesT *>(value) : nullptr;
  }
  UPFDriver::Response::TableOperationCompleteT *AsTableOperationComplete() {
    return type == ResponseUnion_TableOperationComplete ?
      reinterpret_cast<UPFDriver::Response::TableOperationCompleteT *>(value) : nullptr;
  }
  const UPFDriver::Response::TableOperationCompleteT *AsTableOperationComplete() const {
    return type == ResponseUnion_TableOperationComplete ?
      reinterpret_cast<const UPFDriver::Response::TableOperationCompleteT *>(value) : nullptr;
  }
  UPFDriver::Response::MA_ID_ReclaimedT *AsMA_ID_Reclaimed() {
    return type == ResponseUnion_MA_ID_Reclaimed ?
      reinterpret_cast<UPFDriver::Response::MA_ID_ReclaimedT *>(value) : nullptr;
  }
  const UPFDriver::Response::MA_ID_ReclaimedT *AsMA_ID_Reclaimed() const {
    return type == ResponseUnion_MA_ID_Reclaimed ?
      reinterpret_cast<const UPFDriver::Response::MA_ID_ReclaimedT *>(value) : nullptr;
  }
};

bool VerifyResponseUnion(::flatbuffers::Verifier &verifier, const void *obj, ResponseUnion type);
bool VerifyResponseUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct CounterValueT : public ::flatbuffers::NativeTable {
  typedef CounterValue TableType;
  uint32_t ma_id = 0;
  uint64_t bytes = 0;
  uint64_t pkts = 0;
};

struct CounterValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CounterValueT NativeTableType;
  typedef CounterValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MA_ID = 4,
    VT_BYTES = 6,
    VT_PKTS = 8
  };
  uint32_t ma_id() const {
    return GetField<uint32_t>(VT_MA_ID, 0);
  }
  uint64_t bytes() const {
    return GetField<uint64_t>(VT_BYTES, 0);
  }
  uint64_t pkts() const {
    return GetField<uint64_t>(VT_PKTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MA_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_BYTES, 8) &&
           VerifyField<uint64_t>(verifier, VT_PKTS, 8) &&
           verifier.EndTable();
  }
  CounterValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CounterValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CounterValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CounterValueBuilder {
  typedef CounterValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ma_id(uint32_t ma_id) {
    fbb_.AddElement<uint32_t>(CounterValue::VT_MA_ID, ma_id, 0);
  }
  void add_bytes(uint64_t bytes) {
    fbb_.AddElement<uint64_t>(CounterValue::VT_BYTES, bytes, 0);
  }
  void add_pkts(uint64_t pkts) {
    fbb_.AddElement<uint64_t>(CounterValue::VT_PKTS, pkts, 0);
  }
  explicit CounterValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CounterValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CounterValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CounterValue> CreateCounterValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ma_id = 0,
    uint64_t bytes = 0,
    uint64_t pkts = 0) {
  CounterValueBuilder builder_(_fbb);
  builder_.add_pkts(pkts);
  builder_.add_bytes(bytes);
  builder_.add_ma_id(ma_id);
  return builder_.Finish();
}

::flatbuffers::Offset<CounterValue> CreateCounterValue(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CounterValuesT : public ::flatbuffers::NativeTable {
  typedef CounterValues TableType;
  std::vector<std::unique_ptr<UPFDriver::Response::CounterValueT>> values{};
  bool is_ig = false;
  uint64_t ts = 0;
  CounterValuesT() = default;
  CounterValuesT(const CounterValuesT &o);
  CounterValuesT(CounterValuesT&&) FLATBUFFERS_NOEXCEPT = default;
  CounterValuesT &operator=(CounterValuesT o) FLATBUFFERS_NOEXCEPT;
};

struct CounterValues FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CounterValuesT NativeTableType;
  typedef CounterValuesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_IS_IG = 6,
    VT_TS = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>> *>(VT_VALUES);
  }
  bool is_ig() const {
    return GetField<uint8_t>(VT_IS_IG, 0) != 0;
  }
  uint64_t ts() const {
    return GetField<uint64_t>(VT_TS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           VerifyField<uint8_t>(verifier, VT_IS_IG, 1) &&
           VerifyField<uint64_t>(verifier, VT_TS, 8) &&
           verifier.EndTable();
  }
  CounterValuesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CounterValuesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CounterValues> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValuesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CounterValuesBuilder {
  typedef CounterValues Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>>> values) {
    fbb_.AddOffset(CounterValues::VT_VALUES, values);
  }
  void add_is_ig(bool is_ig) {
    fbb_.AddElement<uint8_t>(CounterValues::VT_IS_IG, static_cast<uint8_t>(is_ig), 0);
  }
  void add_ts(uint64_t ts) {
    fbb_.AddElement<uint64_t>(CounterValues::VT_TS, ts, 0);
  }
  explicit CounterValuesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CounterValues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CounterValues>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CounterValues> CreateCounterValues(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>>> values = 0,
    bool is_ig = false,
    uint64_t ts = 0) {
  CounterValuesBuilder builder_(_fbb);
  builder_.add_ts(ts);
  builder_.add_values(values);
  builder_.add_is_ig(is_ig);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CounterValues> CreateCounterValuesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>> *values = nullptr,
    bool is_ig = false,
    uint64_t ts = 0) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>>(*values) : 0;
  return UPFDriver::Response::CreateCounterValues(
      _fbb,
      values__,
      is_ig,
      ts);
}

::flatbuffers::Offset<CounterValues> CreateCounterValues(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValuesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TableOperationCompleteT : public ::flatbuffers::NativeTable {
  typedef TableOperationComplete TableType;
  int32_t code = 0;
  std::vector<uint32_t> transaction_ids{};
};

struct TableOperationComplete FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TableOperationCompleteT NativeTableType;
  typedef TableOperationCompleteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_TRANSACTION_IDS = 6
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *transaction_ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_TRANSACTION_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE, 4) &&
           VerifyOffset(verifier, VT_TRANSACTION_IDS) &&
           verifier.VerifyVector(transaction_ids()) &&
           verifier.EndTable();
  }
  TableOperationCompleteT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TableOperationCompleteT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TableOperationComplete> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TableOperationCompleteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TableOperationCompleteBuilder {
  typedef TableOperationComplete Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(TableOperationComplete::VT_CODE, code, 0);
  }
  void add_transaction_ids(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> transaction_ids) {
    fbb_.AddOffset(TableOperationComplete::VT_TRANSACTION_IDS, transaction_ids);
  }
  explicit TableOperationCompleteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TableOperationComplete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TableOperationComplete>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TableOperationComplete> CreateTableOperationComplete(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> transaction_ids = 0) {
  TableOperationCompleteBuilder builder_(_fbb);
  builder_.add_transaction_ids(transaction_ids);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TableOperationComplete> CreateTableOperationCompleteDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const std::vector<uint32_t> *transaction_ids = nullptr) {
  auto transaction_ids__ = transaction_ids ? _fbb.CreateVector<uint32_t>(*transaction_ids) : 0;
  return UPFDriver::Response::CreateTableOperationComplete(
      _fbb,
      code,
      transaction_ids__);
}

::flatbuffers::Offset<TableOperationComplete> CreateTableOperationComplete(::flatbuffers::FlatBufferBuilder &_fbb, const TableOperationCompleteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MA_ID_ReclaimedT : public ::flatbuffers::NativeTable {
  typedef MA_ID_Reclaimed TableType;
  std::vector<uint32_t> ma_ids{};
};

struct MA_ID_Reclaimed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MA_ID_ReclaimedT NativeTableType;
  typedef MA_ID_ReclaimedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MA_IDS = 4
  };
  const ::flatbuffers::Vector<uint32_t> *ma_ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_MA_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MA_IDS) &&
           verifier.VerifyVector(ma_ids()) &&
           verifier.EndTable();
  }
  MA_ID_ReclaimedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MA_ID_ReclaimedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MA_ID_Reclaimed> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MA_ID_ReclaimedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MA_ID_ReclaimedBuilder {
  typedef MA_ID_Reclaimed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ma_ids(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ma_ids) {
    fbb_.AddOffset(MA_ID_Reclaimed::VT_MA_IDS, ma_ids);
  }
  explicit MA_ID_ReclaimedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MA_ID_Reclaimed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MA_ID_Reclaimed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MA_ID_Reclaimed> CreateMA_ID_Reclaimed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ma_ids = 0) {
  MA_ID_ReclaimedBuilder builder_(_fbb);
  builder_.add_ma_ids(ma_ids);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MA_ID_Reclaimed> CreateMA_ID_ReclaimedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *ma_ids = nullptr) {
  auto ma_ids__ = ma_ids ? _fbb.CreateVector<uint32_t>(*ma_ids) : 0;
  return UPFDriver::Response::CreateMA_ID_Reclaimed(
      _fbb,
      ma_ids__);
}

::flatbuffers::Offset<MA_ID_Reclaimed> CreateMA_ID_Reclaimed(::flatbuffers::FlatBufferBuilder &_fbb, const MA_ID_ReclaimedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResponseT : public ::flatbuffers::NativeTable {
  typedef Response TableType;
  UPFDriver::Response::ResponseUnionUnion response{};
};

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseT NativeTableType;
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  UPFDriver::Response::ResponseUnion response_type() const {
    return static_cast<UPFDriver::Response::ResponseUnion>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const UPFDriver::Response::CounterValues *response_as_CounterValues() const {
    return response_type() == UPFDriver::Response::ResponseUnion_CounterValues ? static_cast<const UPFDriver::Response::CounterValues *>(response()) : nullptr;
  }
  const UPFDriver::Response::TableOperationComplete *response_as_TableOperationComplete() const {
    return response_type() == UPFDriver::Response::ResponseUnion_TableOperationComplete ? static_cast<const UPFDriver::Response::TableOperationComplete *>(response()) : nullptr;
  }
  const UPFDriver::Response::MA_ID_Reclaimed *response_as_MA_ID_Reclaimed() const {
    return response_type() == UPFDriver::Response::ResponseUnion_MA_ID_Reclaimed ? static_cast<const UPFDriver::Response::MA_ID_Reclaimed *>(response()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyResponseUnion(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
  ResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const UPFDriver::Response::CounterValues *Response::response_as<UPFDriver::Response::CounterValues>() const {
  return response_as_CounterValues();
}

template<> inline const UPFDriver::Response::TableOperationComplete *Response::response_as<UPFDriver::Response::TableOperationComplete>() const {
  return response_as_TableOperationComplete();
}

template<> inline const UPFDriver::Response::MA_ID_Reclaimed *Response::response_as<UPFDriver::Response::MA_ID_Reclaimed>() const {
  return response_as_MA_ID_Reclaimed();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_response_type(UPFDriver::Response::ResponseUnion response_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(::flatbuffers::Offset<void> response) {
    fbb_.AddOffset(Response::VT_RESPONSE, response);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UPFDriver::Response::ResponseUnion response_type = UPFDriver::Response::ResponseUnion_NONE,
    ::flatbuffers::Offset<void> response = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

::flatbuffers::Offset<Response> CreateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CounterValueT *CounterValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CounterValueT>(new CounterValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CounterValue::UnPackTo(CounterValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ma_id(); _o->ma_id = _e; }
  { auto _e = bytes(); _o->bytes = _e; }
  { auto _e = pkts(); _o->pkts = _e; }
}

inline ::flatbuffers::Offset<CounterValue> CounterValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCounterValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CounterValue> CreateCounterValue(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CounterValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ma_id = _o->ma_id;
  auto _bytes = _o->bytes;
  auto _pkts = _o->pkts;
  return UPFDriver::Response::CreateCounterValue(
      _fbb,
      _ma_id,
      _bytes,
      _pkts);
}

inline CounterValuesT::CounterValuesT(const CounterValuesT &o)
      : is_ig(o.is_ig),
        ts(o.ts) {
  values.reserve(o.values.size());
  for (const auto &values_ : o.values) { values.emplace_back((values_) ? new UPFDriver::Response::CounterValueT(*values_) : nullptr); }
}

inline CounterValuesT &CounterValuesT::operator=(CounterValuesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(values, o.values);
  std::swap(is_ig, o.is_ig);
  std::swap(ts, o.ts);
  return *this;
}

inline CounterValuesT *CounterValues::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CounterValuesT>(new CounterValuesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CounterValues::UnPackTo(CounterValuesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->values[_i]) { _e->Get(_i)->UnPackTo(_o->values[_i].get(), _resolver); } else { _o->values[_i] = std::unique_ptr<UPFDriver::Response::CounterValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->values.resize(0); } }
  { auto _e = is_ig(); _o->is_ig = _e; }
  { auto _e = ts(); _o->ts = _e; }
}

inline ::flatbuffers::Offset<CounterValues> CounterValues::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValuesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCounterValues(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CounterValues> CreateCounterValues(::flatbuffers::FlatBufferBuilder &_fbb, const CounterValuesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CounterValuesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector<::flatbuffers::Offset<UPFDriver::Response::CounterValue>> (_o->values.size(), [](size_t i, _VectorArgs *__va) { return CreateCounterValue(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _is_ig = _o->is_ig;
  auto _ts = _o->ts;
  return UPFDriver::Response::CreateCounterValues(
      _fbb,
      _values,
      _is_ig,
      _ts);
}

inline TableOperationCompleteT *TableOperationComplete::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TableOperationCompleteT>(new TableOperationCompleteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TableOperationComplete::UnPackTo(TableOperationCompleteT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; }
  { auto _e = transaction_ids(); if (_e) { _o->transaction_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transaction_ids[_i] = _e->Get(_i); } } else { _o->transaction_ids.resize(0); } }
}

inline ::flatbuffers::Offset<TableOperationComplete> TableOperationComplete::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TableOperationCompleteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTableOperationComplete(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TableOperationComplete> CreateTableOperationComplete(::flatbuffers::FlatBufferBuilder &_fbb, const TableOperationCompleteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TableOperationCompleteT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _transaction_ids = _o->transaction_ids.size() ? _fbb.CreateVector(_o->transaction_ids) : 0;
  return UPFDriver::Response::CreateTableOperationComplete(
      _fbb,
      _code,
      _transaction_ids);
}

inline MA_ID_ReclaimedT *MA_ID_Reclaimed::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MA_ID_ReclaimedT>(new MA_ID_ReclaimedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MA_ID_Reclaimed::UnPackTo(MA_ID_ReclaimedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ma_ids(); if (_e) { _o->ma_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ma_ids[_i] = _e->Get(_i); } } else { _o->ma_ids.resize(0); } }
}

inline ::flatbuffers::Offset<MA_ID_Reclaimed> MA_ID_Reclaimed::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MA_ID_ReclaimedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMA_ID_Reclaimed(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MA_ID_Reclaimed> CreateMA_ID_Reclaimed(::flatbuffers::FlatBufferBuilder &_fbb, const MA_ID_ReclaimedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MA_ID_ReclaimedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ma_ids = _o->ma_ids.size() ? _fbb.CreateVector(_o->ma_ids) : 0;
  return UPFDriver::Response::CreateMA_ID_Reclaimed(
      _fbb,
      _ma_ids);
}

inline ResponseT *Response::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResponseT>(new ResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response::UnPackTo(ResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = response_type(); _o->response.type = _e; }
  { auto _e = response(); if (_e) _o->response.value = UPFDriver::Response::ResponseUnionUnion::UnPack(_e, response_type(), _resolver); }
}

inline ::flatbuffers::Offset<Response> Response::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response> CreateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _response_type = _o->response.type;
  auto _response = _o->response.Pack(_fbb);
  return UPFDriver::Response::CreateResponse(
      _fbb,
      _response_type,
      _response);
}

inline bool VerifyResponseUnion(::flatbuffers::Verifier &verifier, const void *obj, ResponseUnion type) {
  switch (type) {
    case ResponseUnion_NONE: {
      return true;
    }
    case ResponseUnion_CounterValues: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::CounterValues *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseUnion_TableOperationComplete: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::TableOperationComplete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseUnion_MA_ID_Reclaimed: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::MA_ID_Reclaimed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponseUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseUnion(
        verifier,  values->Get(i), types->GetEnum<ResponseUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ResponseUnionUnion::UnPack(const void *obj, ResponseUnion type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ResponseUnion_CounterValues: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::CounterValues *>(obj);
      return ptr->UnPack(resolver);
    }
    case ResponseUnion_TableOperationComplete: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::TableOperationComplete *>(obj);
      return ptr->UnPack(resolver);
    }
    case ResponseUnion_MA_ID_Reclaimed: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::MA_ID_Reclaimed *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ResponseUnionUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ResponseUnion_CounterValues: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::CounterValuesT *>(value);
      return CreateCounterValues(_fbb, ptr, _rehasher).Union();
    }
    case ResponseUnion_TableOperationComplete: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::TableOperationCompleteT *>(value);
      return CreateTableOperationComplete(_fbb, ptr, _rehasher).Union();
    }
    case ResponseUnion_MA_ID_Reclaimed: {
      auto ptr = reinterpret_cast<const UPFDriver::Response::MA_ID_ReclaimedT *>(value);
      return CreateMA_ID_Reclaimed(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ResponseUnionUnion::ResponseUnionUnion(const ResponseUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ResponseUnion_CounterValues: {
      value = new UPFDriver::Response::CounterValuesT(*reinterpret_cast<UPFDriver::Response::CounterValuesT *>(u.value));
      break;
    }
    case ResponseUnion_TableOperationComplete: {
      value = new UPFDriver::Response::TableOperationCompleteT(*reinterpret_cast<UPFDriver::Response::TableOperationCompleteT *>(u.value));
      break;
    }
    case ResponseUnion_MA_ID_Reclaimed: {
      value = new UPFDriver::Response::MA_ID_ReclaimedT(*reinterpret_cast<UPFDriver::Response::MA_ID_ReclaimedT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ResponseUnionUnion::Reset() {
  switch (type) {
    case ResponseUnion_CounterValues: {
      auto ptr = reinterpret_cast<UPFDriver::Response::CounterValuesT *>(value);
      delete ptr;
      break;
    }
    case ResponseUnion_TableOperationComplete: {
      auto ptr = reinterpret_cast<UPFDriver::Response::TableOperationCompleteT *>(value);
      delete ptr;
      break;
    }
    case ResponseUnion_MA_ID_Reclaimed: {
      auto ptr = reinterpret_cast<UPFDriver::Response::MA_ID_ReclaimedT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ResponseUnion_NONE;
}

inline const UPFDriver::Response::Response *GetResponse(const void *buf) {
  return ::flatbuffers::GetRoot<UPFDriver::Response::Response>(buf);
}

inline const UPFDriver::Response::Response *GetSizePrefixedResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<UPFDriver::Response::Response>(buf);
}

inline bool VerifyResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UPFDriver::Response::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UPFDriver::Response::Response>(nullptr);
}

inline void FinishResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UPFDriver::Response::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UPFDriver::Response::Response> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<UPFDriver::Response::ResponseT> UnPackResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<UPFDriver::Response::ResponseT>(GetResponse(buf)->UnPack(res));
}

inline std::unique_ptr<UPFDriver::Response::ResponseT> UnPackSizePrefixedResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<UPFDriver::Response::ResponseT>(GetSizePrefixedResponse(buf)->UnPack(res));
}

}  // namespace Response
}  // namespace UPFDriver

#endif  // FLATBUFFERS_GENERATED_RESPONSE_UPFDRIVER_RESPONSE_H_
