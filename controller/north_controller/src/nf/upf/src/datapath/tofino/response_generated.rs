// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod upfdriver {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod response {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPONSE_UNION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPONSE_UNION: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE_UNION: [ResponseUnion; 4] = [
  ResponseUnion::NONE,
  ResponseUnion::CounterValues,
  ResponseUnion::TableOperationComplete,
  ResponseUnion::MA_ID_Reclaimed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResponseUnion(pub u8);
#[allow(non_upper_case_globals)]
impl ResponseUnion {
  pub const NONE: Self = Self(0);
  pub const CounterValues: Self = Self(1);
  pub const TableOperationComplete: Self = Self(2);
  pub const MA_ID_Reclaimed: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CounterValues,
    Self::TableOperationComplete,
    Self::MA_ID_Reclaimed,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CounterValues => Some("CounterValues"),
      Self::TableOperationComplete => Some("TableOperationComplete"),
      Self::MA_ID_Reclaimed => Some("MA_ID_Reclaimed"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ResponseUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ResponseUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ResponseUnion {
    type Output = ResponseUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ResponseUnion {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ResponseUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ResponseUnion {}
pub struct ResponseUnionUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum ResponseUnionT {
  NONE,
  CounterValues(Box<CounterValuesT>),
  TableOperationComplete(Box<TableOperationCompleteT>),
  MAIDReclaimed(Box<MA_ID_ReclaimedT>),
}
impl Default for ResponseUnionT {
  fn default() -> Self {
    Self::NONE
  }
}
impl ResponseUnionT {
  pub fn response_union_type(&self) -> ResponseUnion {
    match self {
      Self::NONE => ResponseUnion::NONE,
      Self::CounterValues(_) => ResponseUnion::CounterValues,
      Self::TableOperationComplete(_) => ResponseUnion::TableOperationComplete,
      Self::MAIDReclaimed(_) => ResponseUnion::MA_ID_Reclaimed,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::CounterValues(v) => Some(v.pack(fbb).as_union_value()),
      Self::TableOperationComplete(v) => Some(v.pack(fbb).as_union_value()),
      Self::MAIDReclaimed(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned CounterValuesT, setting the union to NONE.
  pub fn take_counter_values(&mut self) -> Option<Box<CounterValuesT>> {
    if let Self::CounterValues(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CounterValues(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CounterValuesT.
  pub fn as_counter_values(&self) -> Option<&CounterValuesT> {
    if let Self::CounterValues(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CounterValuesT.
  pub fn as_counter_values_mut(&mut self) -> Option<&mut CounterValuesT> {
    if let Self::CounterValues(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TableOperationCompleteT, setting the union to NONE.
  pub fn take_table_operation_complete(&mut self) -> Option<Box<TableOperationCompleteT>> {
    if let Self::TableOperationComplete(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::TableOperationComplete(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TableOperationCompleteT.
  pub fn as_table_operation_complete(&self) -> Option<&TableOperationCompleteT> {
    if let Self::TableOperationComplete(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TableOperationCompleteT.
  pub fn as_table_operation_complete_mut(&mut self) -> Option<&mut TableOperationCompleteT> {
    if let Self::TableOperationComplete(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MA_ID_ReclaimedT, setting the union to NONE.
  pub fn take_ma_id_reclaimed(&mut self) -> Option<Box<MA_ID_ReclaimedT>> {
    if let Self::MAIDReclaimed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MAIDReclaimed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MA_ID_ReclaimedT.
  pub fn as_ma_id_reclaimed(&self) -> Option<&MA_ID_ReclaimedT> {
    if let Self::MAIDReclaimed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MA_ID_ReclaimedT.
  pub fn as_ma_id_reclaimed_mut(&mut self) -> Option<&mut MA_ID_ReclaimedT> {
    if let Self::MAIDReclaimed(v) = self { Some(v.as_mut()) } else { None }
  }
}
pub enum CounterValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CounterValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CounterValue<'a> {
  type Inner = CounterValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CounterValue<'a> {
  pub const VT_MA_ID: flatbuffers::VOffsetT = 4;
  pub const VT_BYTES: flatbuffers::VOffsetT = 6;
  pub const VT_PKTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CounterValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CounterValueArgs
  ) -> flatbuffers::WIPOffset<CounterValue<'bldr>> {
    let mut builder = CounterValueBuilder::new(_fbb);
    builder.add_pkts(args.pkts);
    builder.add_bytes(args.bytes);
    builder.add_ma_id(args.ma_id);
    builder.finish()
  }

  pub fn unpack(&self) -> CounterValueT {
    let ma_id = self.ma_id();
    let bytes = self.bytes();
    let pkts = self.pkts();
    CounterValueT {
      ma_id,
      bytes,
      pkts,
    }
  }

  #[inline]
  pub fn ma_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CounterValue::VT_MA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bytes(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CounterValue::VT_BYTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pkts(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CounterValue::VT_PKTS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CounterValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("ma_id", Self::VT_MA_ID, false)?
     .visit_field::<u64>("bytes", Self::VT_BYTES, false)?
     .visit_field::<u64>("pkts", Self::VT_PKTS, false)?
     .finish();
    Ok(())
  }
}
#[derive(Debug)]
pub struct CounterValueArgs {
    pub ma_id: u32,
    pub bytes: u64,
    pub pkts: u64,
}
impl<'a> Default for CounterValueArgs {
  #[inline]
  fn default() -> Self {
    CounterValueArgs {
      ma_id: 0,
      bytes: 0,
      pkts: 0,
    }
  }
}

pub struct CounterValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CounterValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ma_id(&mut self, ma_id: u32) {
    self.fbb_.push_slot::<u32>(CounterValue::VT_MA_ID, ma_id, 0);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: u64) {
    self.fbb_.push_slot::<u64>(CounterValue::VT_BYTES, bytes, 0);
  }
  #[inline]
  pub fn add_pkts(&mut self, pkts: u64) {
    self.fbb_.push_slot::<u64>(CounterValue::VT_PKTS, pkts, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CounterValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CounterValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CounterValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CounterValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CounterValue");
      ds.field("ma_id", &self.ma_id());
      ds.field("bytes", &self.bytes());
      ds.field("pkts", &self.pkts());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CounterValueT {
  pub ma_id: u32,
  pub bytes: u64,
  pub pkts: u64,
}
impl Default for CounterValueT {
  fn default() -> Self {
    Self {
      ma_id: 0,
      bytes: 0,
      pkts: 0,
    }
  }
}
impl CounterValueT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CounterValue<'b>> {
    let ma_id = self.ma_id;
    let bytes = self.bytes;
    let pkts = self.pkts;
    CounterValue::create(_fbb, &CounterValueArgs{
      ma_id,
      bytes,
      pkts,
    })
  }
}
pub enum CounterValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CounterValues<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CounterValues<'a> {
  type Inner = CounterValues<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CounterValues<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_IS_IG: flatbuffers::VOffsetT = 6;
  pub const VT_TS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CounterValues { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CounterValuesArgs<'args>
  ) -> flatbuffers::WIPOffset<CounterValues<'bldr>> {
    let mut builder = CounterValuesBuilder::new(_fbb);
    builder.add_ts(args.ts);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.add_is_ig(args.is_ig);
    builder.finish()
  }

  pub fn unpack(&self) -> CounterValuesT {
    let values = self.values().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let is_ig = self.is_ig();
    let ts = self.ts();
    CounterValuesT {
      values,
      is_ig,
      ts,
    }
  }

  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CounterValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CounterValue>>>>(CounterValues::VT_VALUES, None)}
  }
  #[inline]
  pub fn is_ig(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CounterValues::VT_IS_IG, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ts(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CounterValues::VT_TS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CounterValues<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CounterValue>>>>("values", Self::VT_VALUES, false)?
     .visit_field::<bool>("is_ig", Self::VT_IS_IG, false)?
     .visit_field::<u64>("ts", Self::VT_TS, false)?
     .finish();
    Ok(())
  }
}
pub struct CounterValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CounterValue<'a>>>>>,
    pub is_ig: bool,
    pub ts: u64,
}
impl<'a> Default for CounterValuesArgs<'a> {
  #[inline]
  fn default() -> Self {
    CounterValuesArgs {
      values: None,
      is_ig: false,
      ts: 0,
    }
  }
}

pub struct CounterValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CounterValuesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CounterValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CounterValues::VT_VALUES, values);
  }
  #[inline]
  pub fn add_is_ig(&mut self, is_ig: bool) {
    self.fbb_.push_slot::<bool>(CounterValues::VT_IS_IG, is_ig, false);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: u64) {
    self.fbb_.push_slot::<u64>(CounterValues::VT_TS, ts, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CounterValuesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CounterValuesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CounterValues<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CounterValues<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CounterValues");
      ds.field("values", &self.values());
      ds.field("is_ig", &self.is_ig());
      ds.field("ts", &self.ts());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CounterValuesT {
  pub values: Option<Vec<CounterValueT>>,
  pub is_ig: bool,
  pub ts: u64,
}
impl Default for CounterValuesT {
  fn default() -> Self {
    Self {
      values: None,
      is_ig: false,
      ts: 0,
    }
  }
}
impl CounterValuesT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CounterValues<'b>> {
    let values = self.values.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let is_ig = self.is_ig;
    let ts = self.ts;
    CounterValues::create(_fbb, &CounterValuesArgs{
      values,
      is_ig,
      ts,
    })
  }
}
pub enum TableOperationCompleteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableOperationComplete<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableOperationComplete<'a> {
  type Inner = TableOperationComplete<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TableOperationComplete<'a> {
  pub const VT_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSACTION_IDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableOperationComplete { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableOperationCompleteArgs<'args>
  ) -> flatbuffers::WIPOffset<TableOperationComplete<'bldr>> {
    let mut builder = TableOperationCompleteBuilder::new(_fbb);
    if let Some(x) = args.transaction_ids { builder.add_transaction_ids(x); }
    builder.add_code(args.code);
    builder.finish()
  }

  pub fn unpack(&self) -> TableOperationCompleteT {
    let code = self.code();
    let transaction_ids = self.transaction_ids().map(|x| {
      x.into_iter().collect()
    });
    TableOperationCompleteT {
      code,
      transaction_ids,
    }
  }

  #[inline]
  pub fn code(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TableOperationComplete::VT_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn transaction_ids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TableOperationComplete::VT_TRANSACTION_IDS, None)}
  }
}

impl flatbuffers::Verifiable for TableOperationComplete<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("code", Self::VT_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("transaction_ids", Self::VT_TRANSACTION_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct TableOperationCompleteArgs<'a> {
    pub code: i32,
    pub transaction_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TableOperationCompleteArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableOperationCompleteArgs {
      code: 0,
      transaction_ids: None,
    }
  }
}

pub struct TableOperationCompleteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableOperationCompleteBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code(&mut self, code: i32) {
    self.fbb_.push_slot::<i32>(TableOperationComplete::VT_CODE, code, 0);
  }
  #[inline]
  pub fn add_transaction_ids(&mut self, transaction_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableOperationComplete::VT_TRANSACTION_IDS, transaction_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableOperationCompleteBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableOperationCompleteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableOperationComplete<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableOperationComplete<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableOperationComplete");
      ds.field("code", &self.code());
      ds.field("transaction_ids", &self.transaction_ids());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TableOperationCompleteT {
  pub code: i32,
  pub transaction_ids: Option<Vec<u32>>,
}
impl Default for TableOperationCompleteT {
  fn default() -> Self {
    Self {
      code: 0,
      transaction_ids: None,
    }
  }
}
impl TableOperationCompleteT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TableOperationComplete<'b>> {
    let code = self.code;
    let transaction_ids = self.transaction_ids.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    TableOperationComplete::create(_fbb, &TableOperationCompleteArgs{
      code,
      transaction_ids,
    })
  }
}
pub enum MA_ID_ReclaimedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MA_ID_Reclaimed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MA_ID_Reclaimed<'a> {
  type Inner = MA_ID_Reclaimed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MA_ID_Reclaimed<'a> {
  pub const VT_MA_IDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MA_ID_Reclaimed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MA_ID_ReclaimedArgs<'args>
  ) -> flatbuffers::WIPOffset<MA_ID_Reclaimed<'bldr>> {
    let mut builder = MA_ID_ReclaimedBuilder::new(_fbb);
    if let Some(x) = args.ma_ids { builder.add_ma_ids(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MA_ID_ReclaimedT {
    let ma_ids = self.ma_ids().map(|x| {
      x.into_iter().collect()
    });
    MA_ID_ReclaimedT {
      ma_ids,
    }
  }

  #[inline]
  pub fn ma_ids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MA_ID_Reclaimed::VT_MA_IDS, None)}
  }
}

impl flatbuffers::Verifiable for MA_ID_Reclaimed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("ma_ids", Self::VT_MA_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct MA_ID_ReclaimedArgs<'a> {
    pub ma_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for MA_ID_ReclaimedArgs<'a> {
  #[inline]
  fn default() -> Self {
    MA_ID_ReclaimedArgs {
      ma_ids: None,
    }
  }
}

pub struct MA_ID_ReclaimedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MA_ID_ReclaimedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ma_ids(&mut self, ma_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MA_ID_Reclaimed::VT_MA_IDS, ma_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MA_ID_ReclaimedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MA_ID_ReclaimedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MA_ID_Reclaimed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MA_ID_Reclaimed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MA_ID_Reclaimed");
      ds.field("ma_ids", &self.ma_ids());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MA_ID_ReclaimedT {
  pub ma_ids: Option<Vec<u32>>,
}
impl Default for MA_ID_ReclaimedT {
  fn default() -> Self {
    Self {
      ma_ids: None,
    }
  }
}
impl MA_ID_ReclaimedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MA_ID_Reclaimed<'b>> {
    let ma_ids = self.ma_ids.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    MA_ID_Reclaimed::create(_fbb, &MA_ID_ReclaimedArgs{
      ma_ids,
    })
  }
}
pub enum ResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Response<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Response<'a> {
  type Inner = Response<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Response<'a> {
  pub const VT_RESPONSE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_RESPONSE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Response { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResponseArgs
  ) -> flatbuffers::WIPOffset<Response<'bldr>> {
    let mut builder = ResponseBuilder::new(_fbb);
    if let Some(x) = args.response { builder.add_response(x); }
    builder.add_response_type(args.response_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ResponseT {
    let response = match self.response_type() {
      ResponseUnion::NONE => ResponseUnionT::NONE,
      ResponseUnion::CounterValues => ResponseUnionT::CounterValues(Box::new(
        self.response_as_counter_values()
            .expect("Invalid union table, expected `ResponseUnion::CounterValues`.")
            .unpack()
      )),
      ResponseUnion::TableOperationComplete => ResponseUnionT::TableOperationComplete(Box::new(
        self.response_as_table_operation_complete()
            .expect("Invalid union table, expected `ResponseUnion::TableOperationComplete`.")
            .unpack()
      )),
      ResponseUnion::MA_ID_Reclaimed => ResponseUnionT::MAIDReclaimed(Box::new(
        self.response_as_ma_id_reclaimed()
            .expect("Invalid union table, expected `ResponseUnion::MA_ID_Reclaimed`.")
            .unpack()
      )),
      _ => ResponseUnionT::NONE,
    };
    ResponseT {
      response,
    }
  }

  #[inline]
  pub fn response_type(&self) -> ResponseUnion {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ResponseUnion>(Response::VT_RESPONSE_TYPE, Some(ResponseUnion::NONE)).unwrap()}
  }
  #[inline]
  pub fn response(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Response::VT_RESPONSE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_counter_values(&self) -> Option<CounterValues<'a>> {
    if self.response_type() == ResponseUnion::CounterValues {
      self.response().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CounterValues::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_table_operation_complete(&self) -> Option<TableOperationComplete<'a>> {
    if self.response_type() == ResponseUnion::TableOperationComplete {
      self.response().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableOperationComplete::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_ma_id_reclaimed(&self) -> Option<MA_ID_Reclaimed<'a>> {
    if self.response_type() == ResponseUnion::MA_ID_Reclaimed {
      self.response().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MA_ID_Reclaimed::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Response<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ResponseUnion, _>("response_type", Self::VT_RESPONSE_TYPE, "response", Self::VT_RESPONSE, false, |key, v, pos| {
        match key {
          ResponseUnion::CounterValues => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CounterValues>>("ResponseUnion::CounterValues", pos),
          ResponseUnion::TableOperationComplete => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TableOperationComplete>>("ResponseUnion::TableOperationComplete", pos),
          ResponseUnion::MA_ID_Reclaimed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MA_ID_Reclaimed>>("ResponseUnion::MA_ID_Reclaimed", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ResponseArgs {
    pub response_type: ResponseUnion,
    pub response: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ResponseArgs {
  #[inline]
  fn default() -> Self {
    ResponseArgs {
      response_type: ResponseUnion::NONE,
      response: None,
    }
  }
}

pub struct ResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_response_type(&mut self, response_type: ResponseUnion) {
    self.fbb_.push_slot::<ResponseUnion>(Response::VT_RESPONSE_TYPE, response_type, ResponseUnion::NONE);
  }
  #[inline]
  pub fn add_response(&mut self, response: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_RESPONSE, response);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Response<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Response");
      ds.field("response_type", &self.response_type());
      match self.response_type() {
        ResponseUnion::CounterValues => {
          if let Some(x) = self.response_as_counter_values() {
            ds.field("response", &x)
          } else {
            ds.field("response", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponseUnion::TableOperationComplete => {
          if let Some(x) = self.response_as_table_operation_complete() {
            ds.field("response", &x)
          } else {
            ds.field("response", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponseUnion::MA_ID_Reclaimed => {
          if let Some(x) = self.response_as_ma_id_reclaimed() {
            ds.field("response", &x)
          } else {
            ds.field("response", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("response", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ResponseT {
  pub response: ResponseUnionT,
}
impl Default for ResponseT {
  fn default() -> Self {
    Self {
      response: ResponseUnionT::NONE,
    }
  }
}
impl ResponseT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Response<'b>> {
    let response_type = self.response.response_union_type();
    let response = self.response.pack(_fbb);
    Response::create(_fbb, &ResponseArgs{
      response_type,
      response,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Response`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn root_as_response(buf: &[u8]) -> Result<Response, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Response>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Response` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_response_unchecked`.
pub fn size_prefixed_root_as_response(buf: &[u8]) -> Result<Response, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Response>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Response` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn root_as_response_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Response<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Response<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Response` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn size_prefixed_root_as_response_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Response<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Response<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Response and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Response`.
pub unsafe fn root_as_response_unchecked(buf: &[u8]) -> Response {
  flatbuffers::root_unchecked::<Response>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Response and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Response`.
pub unsafe fn size_prefixed_root_as_response_unchecked(buf: &[u8]) -> Response {
  flatbuffers::size_prefixed_root_unchecked::<Response>(buf)
}
#[inline]
pub fn finish_response_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Response<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_response_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Response<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Response
}  // pub mod UPFDriver

